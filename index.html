<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Webcam ASCII Mirror - B&W</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* Fondo negro */
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff; /* Texto blanco */
            font-family: 'Courier New', Courier, monospace;
            height: 100vh;
        }
        
        /* Capa de UI */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            pointer-events: none;
        }

        /* Pantalla de Inicio / Errores */
        #start-screen {
            background: rgba(0,0,0,0.95);
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: auto;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.5rem; letter-spacing: 3px; color: #fff; }
        p { color: #aaa; }
        
        button {
            background: transparent;
            border: 2px solid #fff; /* Bot칩n blanco */
            color: #fff;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
        }
        button:hover { background: #fff; color: #000; }
        button:disabled { border-color: #555; color: #555; pointer-events: none; }

        #error-msg {
            color: #ff5555;
            margin-top: 20px;
            font-size: 0.9rem;
            line-height: 1.4;
            max-width: 90%;
            background: rgba(50,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        #status-bar {
            margin-top: 20px;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            border: 1px solid #333;
        }

        #videoSource { display: none; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>ASCII MIRROR B&W</h1>
        <p style="margin: 0;">TouchDesigner Web Port</p>
        
        <button id="btn-start">ACTIVAR C츼MARA</button>
        
        <div id="error-msg"></div>
        <p style="font-size:0.7rem; margin-top:30px; opacity: 0.7;">
            Requiere acceso a c치mara.<br>El procesamiento se realiza en tu dispositivo.
        </p>
    </div>

    <div id="ui-layer" style="display:none;">
        <div id="status-bar">Iniciando sistema...</div>
    </div>
    
    <video id="videoSource" playsinline webkit-playsinline muted></video>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- VARIABLES ---
        let renderer, scene, camera;
        let video, videoTexture, fontTexture;
        let customMaterial;
        let handLandmarker;
        let lastVideoTime = -1;
        
        let currentEffectValue = 0;
        let targetEffectValue = 0;
        let isHandDetected = false;

        // Elementos DOM
        const startScreen = document.getElementById('start-screen');
        const uiLayer = document.getElementById('ui-layer');
        const btnStart = document.getElementById('btn-start');
        const statusBar = document.getElementById('status-bar');
        const errorMsg = document.getElementById('error-msg');
        const videoElement = document.getElementById('videoSource');

        // --- EVENTO START ---
        btnStart.addEventListener('click', async () => {
            errorMsg.style.display = 'none';
            btnStart.textContent = "SOLICITANDO PERMISOS...";
            btnStart.disabled = true;

            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
                showError("丘멆잺 ERROR DE SEGURIDAD", "La c치mara requiere HTTPS. Usa localhost o sube a GitHub Pages.");
                btnStart.textContent = "ERROR HTTPS";
                return;
            }

            try {
                await init();
                startScreen.style.display = 'none';
                uiLayer.style.display = 'flex';
            } catch (e) {
                console.error("Error completo:", e);
                btnStart.disabled = false;
                btnStart.textContent = "REINTENTAR";
                
                let title = "ERROR T칄CNICO";
                let desc = e.message;

                if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                    title = "游 ACCESO DENEGADO";
                    desc = "El navegador bloque칩 la c치mara. Revisa los permisos en la barra de direcci칩n.";
                } else if (e.name === 'NotFoundError') {
                    title = "游닝 C츼MARA NO DETECTADA";
                    desc = "No se encuentra ninguna c치mara disponible.";
                } else if (e.name === 'NotReadableError') {
                    title = "丘멆잺 C츼MARA OCUPADA";
                    desc = "Otra app est치 usando la c치mara. Cierra todo y recarga.";
                }

                showError(title, desc);
            }
        });

        function showError(title, desc) {
            errorMsg.style.display = 'block';
            errorMsg.innerHTML = `<b>${title}</b><br>${desc}`;
        }

        // --- 1. GENERAR LETRAS ASCII (Blanco sobre Negro) ---
        function createAsciiTexture() {
            const canvas = document.createElement('canvas');
            const chars = " .:-=+*#%@"; 
            const charCount = chars.length;
            const fontSize = 64;
            canvas.width = fontSize * charCount; 
            canvas.height = fontSize;
            const ctx = canvas.getContext('2d');
            // Fondo negro para la textura de fuente
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = `bold ${fontSize}px monospace`;
            // Letras blancas para la textura de fuente
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            for (let i = 0; i < charCount; i++) {
                ctx.fillText(chars[i], i * fontSize + (fontSize / 2), fontSize / 2);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            return { texture, charCount };
        }

        // --- 2. SHADERS (MODIFICADO PARA BLANCO Y NEGRO) ---
        const vertexShader = `
            varying vec2 vUv;
            void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }
        `;

        const fragmentShader = `
            uniform sampler2D tDiffuse;
            uniform sampler2D tFont;
            uniform float uInteraction;
            uniform vec2 uResolution;
            uniform float uCharCount;
            varying vec2 vUv;
            
            float getBrightness(vec3 c) { return dot(c, vec3(0.299, 0.587, 0.114)); }
            
            void main() {
                vec2 uv = vUv;
                vec4 originalColor = texture2D(tDiffuse, uv);
                
                // Configuraci칩n responsiva de densidad
                float columns = uResolution.x / 10.0;
                if (columns < 40.0) columns = 40.0; 
                float ratio = uResolution.x / uResolution.y;
                float rows = columns / ratio;
                
                // Pixelaci칩n y Brillo
                vec2 gridUV = floor(uv * vec2(columns, rows)) / vec2(columns, rows);
                vec3 pixelColor = texture2D(tDiffuse, gridUV).rgb;
                float brightness = getBrightness(pixelColor);
                
                // Selecci칩n de letra
                float charIndex = floor(brightness * (uCharCount - 0.01));
                vec2 cellUV = fract(uv * vec2(columns, rows));
                float fontUV_x = (cellUV.x + charIndex) / uCharCount;
                vec2 fontUV = vec2(fontUV_x, cellUV.y);
                
                // Muestreo de la fuente (fontColor.r es 1.0 donde hay letra, 0.0 donde no)
                vec4 fontColor = texture2D(tFont, fontUV);
                
                // --- L칍GICA DE COLOR MODIFICADA ---
                // Definimos blanco puro
                vec3 whiteColor = vec3(1.0, 1.0, 1.0);
                
                // El color ASCII final es: La forma de la letra (fontColor.r) * Blanco * Brillo original.
                // Multiplicamos por 2.0 para darle un poco m치s de "punch" al blanco.
                vec3 asciiColor = fontColor.r * whiteColor * brightness * 2.0;
                
                // Cuando uInteraction es 1.0, el fondo es negro porque asciiColor es 0.0 donde no hay letra.
                gl_FragColor = vec4(mix(originalColor.rgb, asciiColor, uInteraction), 1.0);
            }
        `;

        // --- 3. INICIALIZACI칍N ---
        async function init() {
            const constraints = {
                audio: false,
                video: {
                    facingMode: 'user',
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                }
            };

            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video = document.getElementById('videoSource');
            video.srcObject = stream;
            
            await new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });

            statusBar.innerText = "Cargando Hand Tracking...";
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            const asciiData = createAsciiTexture();
            fontTexture = asciiData.texture;
            setupThreeJS(asciiData.charCount);
            
            statusBar.innerText = "춰Listo! Junta tus dedos.";
            animate();
        }

        function setupThreeJS(charCount) {
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.colorSpace = THREE.SRGBColorSpace;

            customMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: videoTexture },
                    tFont: { value: fontTexture },
                    uCharCount: { value: charCount },
                    uInteraction: { value: 0.0 },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader
            });

            const plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), customMaterial);
            scene.add(plane);

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                customMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            if (video && video.readyState >= 2 && handLandmarker) {
                if (video.currentTime !== lastVideoTime) {
                    lastVideoTime = video.currentTime;
                    const results = handLandmarker.detectForVideo(video, performance.now());

                    if (results.landmarks.length > 0) {
                        isHandDetected = true;
                        const lm = results.landmarks[0];
                        const d = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                        
                        const minD = 0.03; 
                        const maxD = 0.18;
                        let val = 1.0 - Math.min(Math.max((d - minD) / (maxD - minD), 0.0), 1.0);
                        
                        targetEffectValue = val;
                        statusBar.innerText = `INTENSIDAD: ${(val*100).toFixed(0)}%`;
                        statusBar.style.color = "#fff"; // Texto de estado blanco
                    } else {
                        isHandDetected = false;
                        statusBar.innerText = "MANO NO DETECTADA (LOCKED)";
                        statusBar.style.color = "#ccc";
                    }
                }
            }

            currentEffectValue += (targetEffectValue - currentEffectValue) * 0.1;
            if(customMaterial) customMaterial.uniforms.uInteraction.value = currentEffectValue;
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
